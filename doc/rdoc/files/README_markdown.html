<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README.markdown</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README.markdown</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README.markdown
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Sep 06 14:55:09 +0100 2010</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
Use ruby_events to add event listening and firing capabilities to all Ruby
objects. It&#8216;s simple, fast and remains Ruby-ish in style and usage.
</p>
<p>
## Installation
</p>
<pre>
    gem install ruby_events
</pre>
<p>
## Usage
</p>
<p>
Using ruby_events is simple! Because all objects are automatically extended
with the ruby_events functionality, it&#8216;s as simple as:
</p>
<pre>
    require 'rubygems'
    require 'ruby_events'

    class Example
      def initialize
        events.listen(:test_event) do |event_data|
          puts 'Hai there!'
          puts event_data
        end
      end

      def call_me
        events.fire(:test_event, 'My name is Mr Test Man!')
      end
    end

    e = Example.new
    e.call_me # Fires the event, and our handler gets called!
</pre>
<p>
You can do cooler and more advanced things, like add listeners to an Array:
</p>
<pre>
    a = []

    class &lt;&lt; a
      alias_method :inject_old, :inject

      def inject(item)
        events.fire(:injected, self, item)
        inject_old(item)
      end
    end

    a.events.listen(:injected) do |a, item|
      puts a
      puts item
    end

    a.inject('This is a test')
</pre>
<p>
But because this is a fairly common pattern, ruby_events does it for you
with a little bit of sugar:
</p>
<pre>
    a = []
    a.events.fire_on_method('&lt;&lt;'.to_sym, :item_injected)
    a.events.listen(:injected) do |event_data|
      puts event_data
    end

    a &lt;&lt; 'this is a test'
</pre>
<p>
You can supply the `listen` method with a Proc, an array of Procs, or a
block. You can also give it a mixute of Procs and a block if you really
want:
</p>
<pre>
    a = []
    a.events.fire_on_method('&lt;&lt;'.to_sym, :item_injected)
    a.events.listen(:injected, [Proc.new { |event_data| puts event_data; }, Proc.new { puts 'Hello, I was called!'; }])

    a &lt;&lt; 'this is a test'
</pre>
<p>
These method events will automatically be passed the arguments that were
passed to that method when it was called. Don&#8216;t let your imagination
stop there. You can add an event to any class method, and because all ruby
objects are passed by reference, you can set these arguments and change the
outcome of the function. Effectively, you can use the events as callbacks
on any method:
</p>
<pre>
    a = {:one =&gt; 1}
    b = {:two =&gt; 3}

    a.events.fire_on_method(:merge, :merged)
    a.events.listen(:merged) do |items|
      items[:three] = 3
      puts 'The hash will have the extra item.'
      items
    end

    puts a.merge(b)
</pre>
<p>
All ruby_events functionality is just an object.events call away.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>